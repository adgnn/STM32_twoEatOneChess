# 六子棋（二打一棋）

### 一 数据结构与数据类型

### **结构/定义**

``` c
// 玩家状态定义
#define chooseChess 1
#define chooseDir 2
#define Rest 3

// 颜色定义
#define WHITE         	 0xFFFF
#define BLACK         	 0x0000
#define BLUE         	 0x001F
#define BRED             0XF81F
#define GRED 			 0XFFE0
#define GBLUE			 0X07FF
#define RED           	 0xF800
#define MAGENTA       	 0xF81F
#define GREEN         	 0x07E0
#define CYAN          	 0x7FFF
#define YELLOW        	 0xFFE0
#define BROWN 			 0XBC40 //棕色
#define BRRED 			 0XFC07 //棕红色
#define GRAY  			 0X8430 //灰色

struct Player{    //表示玩家的【所有棋子的状态和坐标】【玩家状态】
int chessState[6] = {1,1,1,1,1,1};
// 以(chessX[0], chessY[0])表示棋子1的位置
int chessX[6] = {};
int chessY[6] = {};

int playerState; //玩家状态
//1：chooseChess待选棋子
//2：chooseDir选中方向
//3：Rest待机
};

```



### **全局变量**

**棋盘数组**
int CB\[5][4]：5行4列的二维数组

- 棋盘中

    - 0：空
    - 1：玩家1的棋子
    - 2：玩家2的棋子

- 初始棋盘：

    | 2    | 2    | 2    | 2    |
    | ---- | ---- | ---- | ---- |
    | 2    | 0    | 0    | 2    |
    | 0    | 0    | 0    | 0    |
    | 1    | 0    | 0    | 1    |
    | 1    | 1    | 1    | 1    |

![1575859597192](构思.assets/1575859597192.png)

**用于走棋的全局临时变量**

int cx：选中棋子的x坐标

int cy：选中棋子的y坐标

int gocx：棋子待走坐标x

int gocy：棋子待走坐标y

**棋子坐标**

STM32开发板LCD屏幕320*240pixels（横竖）

棋盘每格40*40pixels

显示效果：

![1575860319121](构思.assets/1575860319121.png)

> 以左上角起始像素点定位每一格的位置
>
> 1:(20,80)
>
> 2:(20,120)
>
> 3:(20,160)
>
> 4:(20,200)
>
>
>
> 5:(60,80)
>
> 6:(60,120)
>
> 7:(60,160)
>
> 8:(60,200)
>
>
>
> 9:(100,80)
>
> 10:(100,120)
>
> 11:(100,160)
>
> 12:(100,200)
>
>
>
> 13:(140,80)
>
> 14:(140,120)
>
> 15:(140,160)
>
> 16:(140,200)
>
>
>
> 17:(180,80)
>
> 18:(180,120)
>
> 19:(180,160)
>
> 20:(180,200)

``` c
int CBX[5][4]; //存储LCD屏幕上每格左上角的第一个像素的横坐标位置
int CBY[5][4]; //存储LCD屏幕上每格左上角的第一个像素的纵坐标位置

/* 以下是具体实现 */
```



**游戏状态**

enum gameState：游戏状态。

- 1：player1Turn玩家1回合（默认）
- 2：player2Turn玩家2回合
- 3：player1Win游戏结束（玩家1获胜）
- 4：player2Win游戏结束（玩家2获胜）





### 二 中断

**按键外部中断**



### 三 伪代码

**初始化**

``` c
/* 初始化系统时钟 */

/* 初始化LCD */
// 初始化棋盘矩阵
// 显示初始棋盘

/* 初始化按键 */
// 初始化玩家状态（玩家1为待选棋子，玩家2为待机）

/* 初始化数码管 */
// 根据gameState显示相应状态
```



**按键响应**

``` c
/* 按键响应 */
/* 使用6个按键实现选棋子 SW2 SW3 SW4 SW5 SW6 SW7 */
/* SW10上 SW14下 SW11左 SW15右 */
// 每个按键都使用如下代码，或者将playerState部分拆分

/* 选棋子 */
//对其中一个按键，如SW2来说：
switch(gameState){
    case 1: //玩家1的回合
            if(Player1->chessState[0] == 1){
                // 若玩家1的第1个棋子还没被吃
                cx = Player1 -> chessX[0];
                cy = Player1 -> chessY[0]; //更新全局变量cx、cy为玩家1的第1个棋子的坐标
                Player1 -> PlayerState = chooseDir; //将玩家1的状态更新为待选方向
            }
        break;

    case 2: //玩家2的回合
            if(Player2->chessState[0] == 1){
                //若玩家2的第1个棋子还没被吃
                cx = Player2 -> chessX[0];
                cy = Player2 -> chessY[0];
                Player2 -> PlayerState = chooseDir;
            }
    case 3:
        //玩家1获胜
        break;
    case 4:
        //玩家2获胜
        break;
    default:
        break;
}

/* 选方向 */
// 以SW10为例，需要判断cx和cy上面一格是否越界、是否有其它棋子
switch(gameState){
    case 1:
        if(Player1->playerState == chooseDir){
            if(Player1->chessState[0] == 1){
                tempX = cx - 1;
                tempY = cy;
                if(cx >= 0){
                    // 若没有数组越界
                    if(CB[tempX, tempY] == 0){
                        //若对应位置没有棋子，可以移动
                        gocx = tempX;
                        gocy = tempY;
                    }
                }
            }
        }

    case 2:
        if(Player2->playerState == chooseDir){
            if(Player2->chessState[0] == 1){
                tempX = cx - 1;
                tempY = cy;
                if(cx >= 0){
                    // 若没有数组越界
                    if(CB[tempX, tempY] == 0){
                        //若对应位置没有棋子，可以移动
                        gocx = tempX;
                        gocy = tempY;
                    }
                }
            }
        }
    case 3:

        break;
    case 4:

        break;
    default:
        break;
}
```

**根据棋盘数组画棋盘函数**

``` c

void DrawCB()
{
    clearAll();
    DrawCBGrid();
    for(int i=0; i<6; i++){
        //遍历PlayerX->chessState[i]，若棋子没被吃掉，调用函数作棋子图像
        // 玩家1棋子用蓝色，玩家2棋子用绿色
        if(Player1->chessState[i] == 1){
            LCD_DrawAChess(Player1->chessX[i], Player1->chessY[i], i+1, BLUE);
        }
        if(Player2->chessState[i] == 1){
            LCD_DrawAChess(Player2->chessX[i], Player2->chessY[i], i+1, GREEN);
        }
    }
}
```

> 1. 调用全屏清函数
> 2. 调用画格子函数
> 3. 调用画棋子函数

**全屏清函数**

``` c
// 全LCD屏置白色
// 调用作矩形函数清屏
void clearAll()
{
    LCD_DrawRect(0,0,239,319,WHITE);
}
```

**画格子函数**

``` c
/* 在LCD屏幕上作棋盘 */
// 调用作矩形函数画线条

void DrawCBGrid()
{
    /* 外框 */
    //************注释的x和y反过来了****************
    // (80,20) - (240,19)
    // (80,20) - (80, 219)
    // (240, 20) - (240, 221)
    /// (80, 220) - (240, 221)

    LCD_DrawRect(20,80,19,240,RED);
    LCD_DrawRect(20,80,219,80,RED);
    LCD_DrawRect(20,240,221,240,RED);
    LCD_DrawRect(220,80,221,240,RED);
    /* 内线 */
    // 横线
    // (80, 60) - (240, 61)
    // (80, 100) - (240, 101)
    // (80, 140) - (240, 141)
    // (80, 180) - (240, 181)

    LCD_DrawRect(60,80,61,240,RED);
    LCD_DrawRect(100,80,101,240,RED);
    LCD_DrawRect(140,80,141,240,RED);
    LCD_DrawRect(180,80,181,240,RED);

    // 竖线
    // (120, 20) - (121, 220)
    // (160, 20) - (161, 220)
    // (200, 20) - (201, 220)
    LCD_DrawRect(20,120,220,121,RED);
    LCD_DrawRect(20,160,220,161,RED);
    LCD_DrawRect(20,200,220,201,RED);
}

```

**画棋子函数**

``` c
/* 画棋子函数 */
void LCD_DrawAChess(int x, int y, int num, uint16_t GRB)
{
    /*
    x：棋子在CB[5][4]的行坐标
    y：棋子在CB[5][4]的列坐标
    num：表示第几个棋子（根据不同棋子画不同的图像，便于观察）
    */
    LCDX = CBX[x];
    LCDY = CBX[y];
    switch(num){
        case 1:
            // 以1号棋子为例
            // 在LCD对应坐标画一个“一”字
            // 从LCD像素坐标取出格子左上角像素坐标
            LCD_DrawRect(LCDX+20, LCDY+10, LCDX+21, LCDY+30, GRB);
            break;
        case 2:
            // 2号棋子
            // 在LCD对应坐标画一个“+”字
            LCD_DrawRect(LCDX+20, LCDY+10, LCDX+21, LCDY+30, GRB);
            LCD_DrawRect(LCDX+10, LCDY+20, LCDX+30, LCDY+21, GRB);
            break;
        case 3:
            // 3号棋子
            // 画一个“艹”字
            LCD_DrawRect(LCDX+20, LCDY+10, LCDX+21, LCDY+30, GRB);
            LCD_DRAWRect(LCDX+10, LCDY+15, LCDX+30, LCDY+16, GRB);
            LCD_DRAWRect(LCDX+10, LCDY+25, LCDX+30, LCDY+26, GRB);
            break;
        case 4:
            // 4号棋子
            // 画一个“4”字
            LCD_DrawRect(LCDX+10, LCDY+15, LCDX+20, LCDY+16, GRB);
            LCD_DrawRect(LCDX+20, LCDY+15, LCDX+21, LCDY+30, GRB);
            LCD_DrawRect(LCDX+10, LCDY+25, LCDX+30, LCDY+26, GRB);
            brjak;
        case 5:
            // 5号棋子
            // 画一个“5”字
            LCD_DrawRect(LCDX+10, LCDY+10, LCDX+11, LCDY+30, GRB);
            LCD_DrawRect(LCDX+10, LCDY+10, LCDX+20, LCDY+11, GRB);
            LCD_DrawRect(LCDX+20, LCDY+10, LCDX+21, LCDY+30, GRB);
            LCD_DrawRect(LCDX+20, LCDY+30, LCDX+30, LCDY+31, GRB);
            LCD_DrawRect(LCDX+30, LCDY+10, LCDX+31, LCDY+30, GRB);
            break;
        case 6:
            // 6号棋子
            // 画一个“b”
            LCD_DrawRect(LCDX+10, LCDY+15, LCDX+30, LCDY+16, GRB);
            LCD_DrawRect(LCDX+20, LCDY+15, LCDX+21, LCDY+25, GRB);
            LCD_DrawRect(LCDX+20, LCDY+25, LCDX+30, LCDY+26, GRB);
            LCD_DrawRect(LCDX+30, LCDY+15, LCDX+31, LCDY+25, GRB);
            break;
        default:
            break;
    }
}
```



**作矩形函数**

``` c
// 循环调用打点函数（已给出）作矩形
void LCD_DrawRect(u16 ox, u16 oy, u16 ex, u16 ey, uint16_t GRB)
{
    /*
    ox、oy：起始点
    ex、ey：终点
    GRB：颜色
    */
    u16 i, j;
    for(i=ox; i<=ex; i++){
        for(j=oy; j<=ey; j++){
            LCD_DrawPoint(i, j, GRB);
        }
    }
}
```

**打点函数（例程实现）**

``` c
void LCD_DrawPoint(u16 x,u16 y,uint16_t GRB)
	{
        LCD_SetCursor(x,y);
		LCD_IO_WriteReg(0x2C);
		LCD_IO_WriteData(GRB);
	}
```
